# Chain-Validation
[![](https://img.shields.io/badge/made%20by-Protocol%20Labs-blue.svg?style=flat-square)](http://ipn.io)
[![CircleCI](https://circleci.com/gh/filecoin-project/chain-validation.svg?style=svg)](https://circleci.com/gh/filecoin-project/chain-validation)

This library provides tools for validating the correctness of a Filecoin implementation according to the [specification](https://github.com/filecoin-project/specs). 

To maintain consensus, all Filecoin implementations must produce identical state transformations for any (state, message) pair. Further, they must implement the same block reward and chain selection logic. Validating correctness in this respect requires extensive coverage over (state, message) pairs, message sequences, and blockchain structures, and is important in maintaining the security and integrity of the network.

This library designed to allow any implementation of Filecoin to import it, implement a simple “driver” interface, and then run the tests provided by the testing library, passing the driver in as the parameter. 

For a comprehensive project description refer to the [Filecoin Chain-Validation Tools Design Doc](https://docs.google.com/document/d/1o0ODvpKdWsYMK_KmK-j-uPxYei6CZAZ4n_3ilQJPn4A/edit#).

## Goals
- A validation library that is implementation-independent enabling validation suites to be written once and used by different Filecoin implementations.
- High-level script-like methods for constructing long and complex message sequences, and making semantic assertions about the expected state resulting from their application.
- High-level script-like methods for constructing complex blockchain structures containing those messages, and making assertions about the expected state from their evaluation.
- Validation suites with significant coverage over actor state and code paths.
- Integration with both Go-filecoin and Lotus, enabling importing and use of the validation suites.
- Incremental utility to both these implementations while they are in development (rather than requiring an implementation to be complete before validation is useful)

## Non-Goals
- Immediate integration with Filecoin implementations not written in Go (though there should be a path towards this). Other implementations will be expected to write code for their implementation to work with this tool.
- High-performance execution, if this comes at a cost of timeliness or comprehensiveness

## Usage
In order for your Filecoin implementation to use this package it will need to satisfy the following interfaces, described in top-down order:

#### Factories

The Factories interface is passed as a parameter to this libraries [test suite](https://github.com/filecoin-project/chain-validation/tree/08ced579e455ab38f6b1b2686899a0da99688104/pkg/suites).

```go
type Factories interface {
  // Wrapper abstracts the inspection and mutation of
  // an implementation-specific state tree and storage.
  // The interface wraps a single, mutable state.
  NewState() state.Wrapper

  // MessageFactory creates a concrete message object.
  // Integrations should implement this to provide a message value that 
  // will be accepted by the validation engine.
  NewMessageFactory() chain.MessageFactory

  // ActorInfoMapping maps this libraries actor code CID's to an 
  // implementations actor code CID's.
  // This interface will be removed when the spec defines these.
  NewActorInfoMapping() chain.ActorInfoMapping

  // Applier applies messages generated by the MessageFactory to an
  // implementaion's state.
  chain.Applier
}
```

#### Wrapper

The Wrapper provides a means for inspecting the state tree and manipulating its state without the need to apply a message to it.

```go
type Wrapper interface {
  // Returns the CID of the root node of the state tree.
  Cid() cid.Cid

  // Returns the actor state at `address` (or an error if there is none).
  Actor(address address.Address) (Actor, error)

  // Returns the actor storage for the actor at `address` (which is empty if there is no such actor).
  Storage(address address.Address) (Storage, error)

  // Creates a new private key and returns the associated address.
  NewAccountAddress() (address.Address, error)

  // Sign data with addr's key.
  Sign(ctx context.Context, addr address.Address, data []byte) (*types.Signature, error)

  // Installs a new actor in the state tree.
  // This signature will probably become a little more complex when the actor state is non-empty.
  SetActor(address address.Address, code actors.ActorCodeID, balance types.BigInt) (Actor, Storage, error)

  // Installs a new singleton actor in the state tree.
  SetSingletonActor(address actors.SingletonActorID, balance types.BigInt) (Actor, Storage, error)
}

```

##### Actor

Actor is an abstraction over the actor states stored in the root of the state tree.

```go
type Actor interface {
  Code() cid.Cid
  Head() cid.Cid
  Nonce() uint64
  Balance() types.BigInt
}
```

##### Storage

Storage provides a key/value store for actor state.

```go
type Storage interface {
  Get(c cid.Cid, out interface{}) error
}
```

#### MessageFactory

The MessageFactory creates messages that the `Applier` applies to the state tree.

```go
type MessageFactory interface {
  MakeMessage(from, to address.Address, method MethodID, nonce uint64, value, gasPrice, gasLimit types.BigInt, params []byte) (*Message, error)
}
```

#### ActorInfoMapping

ActorInfoMapping maps this libraries actor code CID's to an implementations actor code CID's.
*Note: This interface will be removed when the spec defines these.*

```go
type ActorInfoMapping interface {
  FromSingletonAddress(address actors.SingletonActorID) address.Address
  FromActorCodeCid(code actors.ActorCodeID) cid.Cid
}
```

#### Applier

Applier applies messages produced by the `MessageFactory` to the state tree, returning a Receipt or an error.

```go
type Applier interface {
  ApplyMessage(context *ExecutionContext, state state.Wrapper, msg *Message) (MessageReceipt, error)
}
```

